<html>
<head>
	
	<title>Kickstart Practice Round 2017</title>
	<meta name="keywords" content="fzb.me,冯宗宝,冯宗宝的blog" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css" />
    
        
<script src="/js/util.js"></script>

        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3"/>
    
    

<meta name="generator" content="Hexo 6.2.0"></head>

<body>


<h2 class="title">Kickstart Practice Round 2017</h2>
<!--
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2017年3月3日


    <a class="article-category-link" href="/categories/%E9%A2%98%E8%AE%B0/">题记</a>



 </div>
-->
</div>

<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-Country-Leader"><span class="toc-text">A.Country Leader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Vote"><span class="toc-text">B.Vote</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-Sherlock-and-Parentheses"><span class="toc-text">C. Sherlock and Parentheses</span></a></li></ol>
<p>又是好久没写blog了。。。这周末要做kickstart，拿一个practice round练一练，发现这三道题还是挺简单的，主要很想记录一下B题Vote的，这个题和spoj上的<a target="_blank" rel="noopener" href="http://www.spoj.com/problems/INS14G/">INS14G - Kill them All</a>是一样的思路，当初好不容易想明白，结果自己做的时候又有些忘记了。。。</p>
<blockquote>
<p>好累啊，一年又一年，没有活成我想要的样子，没有去我想去的地方。</p>
</blockquote>
<p>今年希望将自己的理想可以实现～</p>
<span id="more"></span>

<h3 id="A-Country-Leader"><a href="#A-Country-Leader" class="headerlink" title="A.Country Leader"></a>A.Country Leader</h3><p>Problem</p>
<p>The Constitution of a certain country states that the leader is the person with the name containing the greatest number of different alphabet letters. (The country uses the uppercase English alphabet from A through Z.) For example, the name GOOGLE has four different alphabet letters: E, G, L, and O. The name APAC CODE JAM has eight different letters. If the country only consists of these 2 persons, APAC CODE JAM would be the leader.</p>
<p>If there is a tie, the person whose name comes earliest in alphabetical order is the leader.</p>
<p>Given a list of names of the citizens of the country, can you determine who the leader is?<br>Input</p>
<p>The first line of the input gives the number of test cases, T. T test cases follow. Each test case starts with a line with an interger N, the number of people in the country. Then N lines follow. The i-th line represents the name of the i-th person. Each name contains at most 20 characters and contains at least one alphabet letter.</p>
<p>Output</p>
<p>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the name of the leader.<br>Limits</p>
<p>1 ≤ T ≤ 100.<br>1 ≤ N ≤ 100.<br>Small dataset</p>
<p>Each name consists of at most 20 characters and only consists of the uppercase English letters A through Z.</p>
<p>Large dataset</p>
<p>Each name consists of at most 20 characters and only consists of the uppercase English letters A through Z and ‘ ‘(space).<br>All names start and end with alphabet letters.<br>Sample</p>
<p>Input<br>2<br>3<br>ADAM<br>BOB<br>JOHNSON<br>2<br>A AB C<br>DEF</p>
<p>Output </p>
<p>Case #1: JOHNSON<br>Case #2: A AB C</p>
<p>In sample case #1, JOHNSON contains 5 different alphabet letters(‘H’, ‘J’, ‘N’, ‘O’, ‘S’), so he is the leader.</p>
<p>Sample case #2 would only appear in Large data set. The name DEF contains 3 different alphabet letters, the name A AB C also contains 3 different alphabet letters. A AB C comes alphabetically earlier so he is the leader.</p>
<blockquote>
<p>题意就是找字符串中字符种类最多的那一个，如果同样多，那么选择字典序最少的那一个。</p>
</blockquote>
<p>直接模拟即可。主要就是getline(cin,t)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">sa</span>(n);</span><br><span class="line">	string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	string res_nxt = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> tmp;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;tmp);</span><br><span class="line">	<span class="built_in">repp</span>(i, <span class="number">1</span>, n)</span><br><span class="line">	&#123;</span><br><span class="line">		string t;</span><br><span class="line">		<span class="built_in">getline</span>(cin, t);</span><br><span class="line">		map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;hax;</span><br><span class="line">		string nxt;</span><br><span class="line">		<span class="built_in">rep</span>(i, <span class="number">0</span>, t.<span class="built_in">length</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (t[i] == <span class="string">&#x27; &#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">			hax[t[i]]++;</span><br><span class="line">			nxt.<span class="built_in">push_back</span>(t[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (hax.<span class="built_in">size</span>() &gt; cnt)</span><br><span class="line">		&#123;</span><br><span class="line">			cnt = hax.<span class="built_in">size</span>();</span><br><span class="line">			res = t;</span><br><span class="line">			res_nxt = nxt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (hax.<span class="built_in">size</span>() == cnt)</span><br><span class="line">		&#123;</span><br><span class="line">			res = <span class="built_in">min</span>(res, t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;i.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;o.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">sa</span>(t);</span><br><span class="line">	<span class="built_in">repp</span>(i, <span class="number">1</span>, t)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, i);</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	&#125;<span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="B-Vote"><a href="#B-Vote" class="headerlink" title="B.Vote"></a>B.Vote</h3><p>Problem</p>
<p>A and B are the only two candidates competing in a certain election. We know from polls that exactly N voters support A, and exactly M voters support B. We also know that N is greater than M, so A will win.</p>
<p>Voters will show up at the polling place one at a time, in an order chosen uniformly at random from all possible (N + M)! orders. After each voter casts their vote, the polling place worker will update the results and note which candidate (if any) is winning so far. (If the votes are tied, neither candidate is considered to be winning.)</p>
<p>What is the probability that A stays in the lead the entire time – that is, that A will always be winning after every vote?</p>
<p>Input</p>
<p>The input starts with one line containing one integer T, which is the number of test cases. Each test case consists of one line with two integers N and M: the numbers of voters supporting A and B, respectively.</p>
<p>Output</p>
<p>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the probability that A will always be winning after every vote.</p>
<p>y will be considered correct if y is within an absolute or relative error of 10-6 of the correct answer. See the FAQ for an explanation of what that means, and what formats of real numbers we accept.</p>
<p>Limits</p>
<p>1 ≤ T ≤ 100.<br>Small dataset</p>
<p>0 ≤ M &lt; N ≤ 10.<br>Large dataset</p>
<p>0 ≤ M &lt; N ≤ 2000.<br>Sample</p>
<p>Input </p>
<p>2<br>2 1<br>1 0</p>
<p>Output </p>
<p>Case #1: 0.33333333<br>Case #2: 1.00000000</p>
<p>In sample case #1, there are 3 voters. Two of them support A – we will call them A1 and A2 – and one of them supports B. They can come to vote in six possible orders: A1 A2 B, A2 A1 B, A1 B A2, A2 B A1, B A1 A2, B A2 A1. Only the first two of those orders guarantee that Candidate A is winning after every vote. (For example, if the order is A1 B A2, then Candidate A is winning after the first vote but tied after the second vote.) So the answer is 2&#x2F;6 &#x3D; 0.333333…</p>
<p>In sample case #2, there is only 1 voter, and that voter supports A. There is only one possible order of arrival, and A will be winning after the one and only vote.</p>
<blockquote>
<p>题意是给出有n个1，m个0，要求这个字符串里面任意一个位置x，字符串[1..x]里面1都比0多，问有多少种方案。</p>
</blockquote>
<p>和每日一题是一样的思路，你假设从[1,1]走到[n+m,n-m]，里面向上走n-1次，向下走m次，不能碰到x坐标轴，正常的方案是<br>$$<br>C\begin{pmatrix}<br>n+m-1\<br>n-1<br>\end{pmatrix}<br>$$<br>然后减去不合法的方案数，就是相当于你这条走过的线碰到了x轴，那么以x轴为对称轴，将碰到x轴之前的那段路径做一个对称，会发现这部分不合法的方案就是从[1,-1]到[n+m,n-m]的方案数，这部分为<br>$$<br>C\begin{pmatrix}<br>n+m-1\<br>n<br>\end{pmatrix}<br>$$<br>然后乘以$m!*n!$除以$(m+n)!$。</p>
<p>得到结果即是<br>$$<br>\frac{n-m}{n+m}<br>$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sa</span>(n), <span class="built_in">sa</span>(m);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.7lf\n&quot;</span>, (<span class="number">1.0</span>*n - m) / (n + m));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;i.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;o.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">sa</span>(t);</span><br><span class="line">	<span class="built_in">repp</span>(i, <span class="number">1</span>, t)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, i);</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	&#125;<span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-Sherlock-and-Parentheses"><a href="#C-Sherlock-and-Parentheses" class="headerlink" title="C. Sherlock and Parentheses"></a>C. Sherlock and Parentheses</h3><p>Problem</p>
<p>Sherlock and Watson have recently enrolled in a computer programming course. Today, the tutor taught them about the balanced parentheses problem. A string S consisting only of characters ( and&#x2F;or ) is balanced if:<br>It is the empty string, or:<br>It has the form (S), where S is a balanced string, or:<br>It has the form S1S2, where S1 is a balanced string and S2 is a balanced string.</p>
<p>Sherlock coded up the solution very quickly and started bragging about how good he is, so Watson gave him a problem to test his knowledge. He asked Sherlock to generate a string S of L + R characters, in which there are a total of L left parentheses ( and a total of R right parentheses ). Moreover, the string must have as many different balanced non-empty substrings as possible. (Two substrings are considered different as long as they start or end at different indexes of the string, even if their content happens to be the same). Note that S itself does not have to be balanced.</p>
<p>Sherlock is sure that once he knows the maximum possible number of balanced non-empty substrings, he will be able to solve the problem. Can you help him find that maximum number?<br>Input</p>
<p>The first line of the input gives the number of test cases, T. T test cases follow. Each test case consists of one line with two integers: L and R.</p>
<p>Output</p>
<p>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the answer, as described above.</p>
<p>Limits</p>
<p>1 ≤ T ≤ 100.<br>Small dataset</p>
<p>0 ≤ L ≤ 20.<br>0 ≤ R ≤ 20.<br>1 ≤ L + R ≤ 20.<br>Large dataset</p>
<p>0 ≤ L ≤ 105.<br>0 ≤ R ≤ 105.<br>1 ≤ L + R ≤ 105.<br>Sample</p>
<p>Input<br> 3<br>1 0<br>1 1<br>3 2<br>Output </p>
<p>Case #1: 0<br>Case #2: 1<br>Case #3: 3</p>
<p>In Case 1, the only possible string is (. There are no balanced non-empty substrings.<br>In Case 2, the optimal string is (). There is only one balanced non-empty substring: the entire string itself.<br>In Case 3, both strings ()()( and (()() give the same optimal answer.<br>For the case ()()(, for example, the three balanced substrings are () from indexes 1 to 2, () from indexes 3 to 4, and ()() from indexes 1 to 4.</p>
<blockquote>
<p>题意是给出左括号与右括号的数量，问最多可以组成多少合法括号的子串。</p>
</blockquote>
<p>求出左括号与右括号的值n，然后发现就是()()()…这样的，那即是<br>$$<br>\frac{n*(n+1)}{2}<br>$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ll m, n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	ll minn = <span class="built_in">min</span>(n, m);</span><br><span class="line">	ll res = (minn + <span class="number">1</span>)*minn / <span class="number">2</span>;</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;i.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;o.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">sa</span>(t);</span><br><span class="line">	<span class="built_in">repp</span>(i, <span class="number">1</span>, t)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, i);</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<!--<a href="http://2997ms.github.io/2017/03/03/CP/Google/Kickstart-Practice-Round-2017/#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = ''; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=&web_id=" language="JavaScript"></script>script>
</div>






</body>
</html>